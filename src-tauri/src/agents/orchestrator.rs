// Cerebras-MAKER: The L2 Technical Orchestrator
// PRD Section 2 (Phase B): PLAN.md → script.rhai
// Takes refined requirements from L1 and generates executable Rhai scripts

use super::{Agent, AgentContext, MicroTask, PlanOutput};
use crate::generators::{GeneratorRegistry, GenerationResult, GeneratorError, RhaiScriptGenerator, TaskScriptGenerator};
use crate::llm::{PromptContext, SystemPrompts};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::RwLock;

/// Execution state for a task
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TaskState {
    Pending,
    Running,
    Completed,
    Failed(String),
    Skipped,
}

/// Execution event for logging
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionEvent {
    pub event_type: String,
    pub task_id: String,
    pub timestamp: String,
    pub message: String,
    pub data: Option<serde_json::Value>,
}

/// The Orchestrator Agent
/// Coordinates script generators and manages task execution pipeline
pub struct Orchestrator {
    /// Generator registry for script generation
    registry: Arc<GeneratorRegistry>,
    /// Default k-threshold for consensus voting
    pub default_k_threshold: usize,
    /// Execution log
    execution_log: Arc<RwLock<Vec<ExecutionEvent>>>,
    /// Task states
    task_states: Arc<RwLock<std::collections::HashMap<String, TaskState>>>,
}

impl Default for Orchestrator {
    fn default() -> Self {
        Self::new()
    }
}

impl Agent for Orchestrator {
    fn name(&self) -> &str {
        "Orchestrator"
    }

    fn system_prompt(&self) -> &str {
        SystemPrompts::orchestrator()
    }
}

impl Orchestrator {
    pub fn new() -> Self {
        let registry = Arc::new(GeneratorRegistry::new());

        Self {
            registry,
            default_k_threshold: 3,
            execution_log: Arc::new(RwLock::new(Vec::new())),
            task_states: Arc::new(RwLock::new(std::collections::HashMap::new())),
        }
    }

    /// Initialize the orchestrator with default generators
    pub async fn init(&self) {
        // Register default generators
        self.registry.register(TaskScriptGenerator::new()).await;
        self.registry.register(RhaiScriptGenerator::new()).await;
    }

    /// Get the generator registry for custom registration
    pub fn registry(&self) -> &GeneratorRegistry {
        &self.registry
    }

    /// Log an execution event
    async fn log_event(&self, event_type: &str, task_id: &str, message: &str, data: Option<serde_json::Value>) {
        let event = ExecutionEvent {
            event_type: event_type.to_string(),
            task_id: task_id.to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            message: message.to_string(),
            data,
        };

        let mut log = self.execution_log.write().await;
        log.push(event);
    }

    /// Update task state
    async fn set_task_state(&self, task_id: &str, state: TaskState) {
        let mut states = self.task_states.write().await;
        states.insert(task_id.to_string(), state);
    }

    /// Generate a Rhai script for a micro-task using the generator pipeline
    pub async fn generate_script(&self, task: &MicroTask, context: &AgentContext) -> Result<GenerationResult, GeneratorError> {
        self.log_event("script_generation_started", &task.id, "Generating script", None).await;
        self.set_task_state(&task.id, TaskState::Running).await;

        // Build prompt context from agent context
        let prompt_context = PromptContext::new()
            .with_workspace(&context.workspace_path)
            .with_var("task_id", &task.id)
            .with_var("task_description", &task.description);

        // Use the generator registry to find and use the best generator
        let result = self.registry.generate(task, &prompt_context).await;

        match &result {
            Ok(gen_result) => {
                self.log_event(
                    "script_generation_completed",
                    &task.id,
                    &format!("Script generated by {}", gen_result.metadata.generator_name),
                    Some(serde_json::json!({
                        "confidence": gen_result.confidence,
                        "generation_time_ms": gen_result.metadata.generation_time_ms
                    })),
                ).await;
                self.set_task_state(&task.id, TaskState::Completed).await;
            }
            Err(e) => {
                self.log_event(
                    "script_generation_failed",
                    &task.id,
                    &format!("Generation failed: {}", e),
                    None,
                ).await;
                self.set_task_state(&task.id, TaskState::Failed(e.to_string())).await;
            }
        }

        result
    }

    /// Generate scripts for all tasks in a plan
    pub async fn generate_execution_plan(&self, plan: &PlanOutput, context: &AgentContext) -> Vec<Result<GenerationResult, GeneratorError>> {
        self.log_event("plan_execution_started", &plan.plan_id, &plan.title, None).await;

        let mut results = Vec::with_capacity(plan.micro_tasks.len());

        // TODO: Respect dependencies and parallelize where possible
        for task in &plan.micro_tasks {
            let result = self.generate_script(task, context).await;
            results.push(result);
        }

        self.log_event("plan_execution_completed", &plan.plan_id, "All scripts generated", None).await;
        results
    }

    /// Get the execution log
    pub async fn get_execution_log(&self) -> Vec<ExecutionEvent> {
        let log = self.execution_log.read().await;
        log.clone()
    }

    /// Get all task states
    pub async fn get_task_states(&self) -> std::collections::HashMap<String, TaskState> {
        let states = self.task_states.read().await;
        states.clone()
    }

    /// Clear the execution log
    pub async fn clear_log(&self) {
        let mut log = self.execution_log.write().await;
        log.clear();
    }

    // ========================================================================
    // L2 Technical Orchestrator Methods
    // ========================================================================

    /// Parse a PLAN.md document and extract structured tasks
    /// This is the entry point for L2 processing
    pub fn parse_plan_md(&self, plan_content: &str) -> Result<PlanOutput, String> {
        // Parse markdown to extract tasks
        let mut micro_tasks = Vec::new();
        let mut current_phase = String::new();
        let mut task_counter = 0;

        for line in plan_content.lines() {
            let trimmed = line.trim();

            // Detect phase headers (## Phase N: ...)
            if trimmed.starts_with("## Phase") || trimmed.starts_with("## ") {
                current_phase = trimmed.trim_start_matches('#').trim().to_string();
                continue;
            }

            // Detect task items (- [ ] Task description)
            if trimmed.starts_with("- [ ]") || trimmed.starts_with("- [x]") {
                task_counter += 1;
                let description = trimmed
                    .trim_start_matches("- [ ]")
                    .trim_start_matches("- [x]")
                    .trim()
                    .to_string();

                // Determine atom type from task description
                let atom_type = Self::infer_atom_type(&description);

                micro_tasks.push(MicroTask {
                    id: format!("t{}", task_counter),
                    description,
                    atom_type,
                    estimated_complexity: 3, // Default medium complexity
                    seed_symbols: Vec::new(),
                });
            }
        }

        if micro_tasks.is_empty() {
            return Err("No tasks found in PLAN.md".to_string());
        }

        Ok(PlanOutput {
            plan_id: format!("plan_{}", chrono::Utc::now().timestamp()),
            title: current_phase.clone(),
            description: "Auto-parsed from PLAN.md".to_string(),
            micro_tasks,
            dependencies: Vec::new(), // TODO: Parse dependencies
        })
    }

    /// Infer the AtomType from task description
    fn infer_atom_type(description: &str) -> String {
        let desc_lower = description.to_lowercase();

        if desc_lower.contains("test") || desc_lower.contains("verify") || desc_lower.contains("assert") {
            "Tester".to_string()
        } else if desc_lower.contains("review") || desc_lower.contains("check") || desc_lower.contains("validate") {
            "Reviewer".to_string()
        } else if desc_lower.contains("design") || desc_lower.contains("architect") || desc_lower.contains("interface") {
            "Architect".to_string()
        } else if desc_lower.contains("analyze") || desc_lower.contains("topology") || desc_lower.contains("dependency") {
            "GritsAnalyzer".to_string()
        } else {
            "Coder".to_string() // Default to Coder
        }
    }

    /// Generate a master Rhai script that orchestrates all tasks
    /// This is the main L2 output
    pub async fn generate_master_script(&self, plan: &PlanOutput, context: &AgentContext) -> Result<String, String> {
        self.log_event("l2_generation_started", &plan.plan_id, "Generating master Rhai script", None).await;

        let mut script = String::new();

        // Header
        script.push_str("// Auto-generated by L2 Technical Orchestrator\n");
        script.push_str(&format!("// Plan: {}\n", plan.title));
        script.push_str(&format!("// Generated: {}\n\n", chrono::Utc::now().to_rfc3339()));

        // Import MAKER preamble
        script.push_str("// MAKER Standard Library\n");
        script.push_str("let k_threshold = 3;\n\n");

        // Generate task execution blocks
        for task in &plan.micro_tasks {
            script.push_str(&format!("// Task: {} - {}\n", task.id, task.description));
            script.push_str(&format!("let {}_result = spawn_atom(\"{}\", \"{}\", k_threshold);\n",
                task.id.replace('-', "_"),
                task.atom_type,
                task.description.replace('"', "\\\"")
            ));
            script.push_str(&format!("if !{}_result.success {{ return #{{ error: \"Task {} failed\" }}; }}\n\n",
                task.id.replace('-', "_"),
                task.id
            ));
        }

        // Final result
        script.push_str("// All tasks completed\n");
        script.push_str("#{ success: true, tasks_completed: ");
        script.push_str(&plan.micro_tasks.len().to_string());
        script.push_str(" }\n");

        self.log_event("l2_generation_completed", &plan.plan_id, "Master script generated",
            Some(serde_json::json!({ "script_length": script.len() }))).await;

        Ok(script)
    }

    /// Full L2 pipeline: PLAN.md → Rhai script
    pub async fn process_plan(&self, plan_content: &str, context: &AgentContext) -> Result<String, String> {
        // Step 1: Parse PLAN.md
        let plan = self.parse_plan_md(plan_content)?;

        // Step 2: Generate master script
        let script = self.generate_master_script(&plan, context).await?;

        Ok(script)
    }
}

