// Cerebras-MAKER: Task-Specific Script Generator
// Generates optimized scripts based on task type

use super::{GenerationMetadata, GenerationResult, GeneratorError, ScriptGenerator};
use crate::agents::{MicroTask, ScriptOutput};
use crate::llm::PromptContext;
use async_trait::async_trait;
use std::time::Instant;

/// Task-specific script generator with templates
pub struct TaskScriptGenerator {
    /// Default k-threshold for consensus
    default_k: usize,
}

impl Default for TaskScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl TaskScriptGenerator {
    pub fn new() -> Self {
        Self { default_k: 3 }
    }

    /// Generate script for Search tasks
    fn generate_search_script(&self, task: &MicroTask) -> String {
        format!(
            r#"// Search Task: {}
// Generated by TaskScriptGenerator

let query = "{}";
let result = spawn_atom(AtomType::Search, query);

if result.is_err {{
    log_error("Search failed: " + result.error);
    throw result.error;
}}

log("Search completed: " + result.value.len() + " results");
result.value
"#,
            task.id,
            task.description.replace('"', r#"\""#)
        )
    }

    /// Generate script for Coder tasks
    fn generate_coder_script(&self, task: &MicroTask) -> String {
        format!(
            r#"// Coder Task: {}
// Generated by TaskScriptGenerator

// 1. Create snapshot
snapshot("Before: {}");

// 2. Gather context
let context = spawn_atom(AtomType::Search, "Find code related to: {}");

// 3. Generate code with consensus
let task_prompt = "{}" + "\n\nContext:\n" + context.value;
let result = vote(AtomType::Coder, task_prompt, {});

if result.is_err {{
    log_error("Consensus failed: " + result.error);
    rollback();
    throw result.error;
}}

// 4. Red-flag check
let flags = check_red_flags(result.value);
if flags.introduced_cycle {{
    log_error("Architectural violation detected");
    rollback();
    throw "Red flag: dependency cycle introduced";
}}

// 5. Success
log("Code generation completed for: {}");
result.value
"#,
            task.id,
            task.id,
            task.seed_symbols.join(", "),
            task.description.replace('"', r#"\""#),
            self.default_k,
            task.id
        )
    }

    /// Generate script for Reviewer tasks
    fn generate_reviewer_script(&self, task: &MicroTask) -> String {
        format!(
            r#"// Reviewer Task: {}
// Generated by TaskScriptGenerator

let code_to_review = "{}";
let review = vote(AtomType::Reviewer, "Review this code:\n" + code_to_review, 2);

if review.is_err {{
    log_error("Review failed: " + review.error);
    throw review.error;
}}

if review.value.contains("REJECT") {{
    log_error("Code review rejected");
    throw "Code review failed: " + review.value;
}}

log("Review passed for: {}");
review.value
"#,
            task.id,
            task.description.replace('"', r#"\""#),
            task.id
        )
    }

    /// Generate script for Validator tasks
    fn generate_validator_script(&self, task: &MicroTask) -> String {
        format!(
            r#"// Validator Task: {}
// Generated by TaskScriptGenerator

let validation_target = "{}";
let result = spawn_atom(AtomType::Validator, validation_target);

if result.is_err {{
    log_error("Validation failed: " + result.error);
    throw result.error;
}}

if !result.value.is_valid {{
    log_error("Validation did not pass");
    throw "Validation failed: " + result.value.reason;
}}

log("Validation passed for: {}");
result.value
"#,
            task.id,
            task.description.replace('"', r#"\""#),
            task.id
        )
    }
}

#[async_trait]
impl ScriptGenerator for TaskScriptGenerator {
    fn name(&self) -> &str {
        "task_template_generator"
    }

    fn description(&self) -> &str {
        "Template-based generator optimized for specific task types"
    }

    fn can_handle(&self, task: &MicroTask) -> bool {
        matches!(
            task.atom_type.as_str(),
            "Search" | "Coder" | "Reviewer" | "Validator"
        )
    }

    fn priority(&self) -> i32 {
        // Higher priority than LLM generator for known task types
        10
    }

    async fn generate(
        &self,
        task: &MicroTask,
        _context: &PromptContext,
    ) -> Result<GenerationResult, GeneratorError> {
        let start = Instant::now();

        let rhai_code = match task.atom_type.as_str() {
            "Search" => self.generate_search_script(task),
            "Coder" => self.generate_coder_script(task),
            "Reviewer" => self.generate_reviewer_script(task),
            "Validator" => self.generate_validator_script(task),
            _ => return Err(GeneratorError::InvalidTask(
                format!("Unknown task type: {}", task.atom_type)
            )),
        };

        let elapsed = start.elapsed();

        Ok(GenerationResult {
            script: ScriptOutput {
                script_id: format!("tpl_{}", uuid::Uuid::new_v4()),
                task_id: task.id.clone(),
                rhai_code,
            },
            confidence: 0.95, // Templates are reliable
            warnings: vec![],
            metadata: GenerationMetadata {
                generator_name: self.name().to_string(),
                generation_time_ms: elapsed.as_millis() as u64,
                prompt_tokens: None,
                completion_tokens: None,
                model_used: None,
            },
        })
    }
}

